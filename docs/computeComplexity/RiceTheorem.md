---
title: 莱斯定理(Rice's Theorem)的简单证明：
date: 2021-11-24
description: 莱斯定理(Rice's Theorem)的简单证明：
categories:
- 基础知识
- 大三上
- 计算复杂性
- 计算理论
tags:
- c
- 图灵机
- 理论
---

# 莱斯定理(Rice's Theorem)的简单证明：

## 莱斯定理的定义：

### 英文版定义：

- Any nontrivial property about the language recognized by a Turing machine is undecidable.

### 中文翻译：

- 递归可枚举语言的任何非平凡的性质，都是不可判定的。

### 翻译成人话：

#### 什么是递归可枚举语言？

考虑一个问题：验证字符串w属于语言L。

我们把字符串输入图灵机，然后看图灵机停不停机，只要停机，那就说明w属于L，

至于图灵机此时的停机状态，根本不必管。

换句话说，只要w确实是属于L的，那么验证这件事就一定能办到，对于L中的元素，我一一验证，总有一天会验证到这个w，这就是可枚举的意思。

图灵机找到通过把w与L中的字符串一一对不，这个过程就叫做递归。

> 递归可枚举与图灵机半判定等价！

#### 什么是非平凡性质？

- 打个比方，人类是一种动物，我们都需要吃饭、喝水和嘘嘘，但是我们为什么被称为人类呢？

- > 一般认为，人与动物的本质区别在于制造与使用工具。

在这个例子中:

- 平凡性质：吃饭、喝水和嘘嘘等等大家都可以做的事情
- 非平凡性质：人类可以制造与使用工具

#### 什么是不可判定？

就是无法找到一个完美的算法，单独用这个算法就可以解决问题。

至此，我们把这句话翻译成了人话。

## 莱斯定理的证明：

一切的问题都能用反证法和数学归纳法解决，所以我们用反证法来证明：

直接找一个不讲武德的反例子：

我们假设，又一个叫做“divides_by_zero()”的算法可以完美解决解决分母为0的问题

然后我们构建一个程序bad();

```c
int bad(int num){
  if(divides_by_zero(bad)){
    int a = 1;
  }
  else{
    int a = 0;
  }
  return num/a;
}
```

如果divides_by_zero()说bad()会有除零的错误，那么我们执行bad()，却不会遇到该错误。

反之，如果divides_by_zero()说不会有除零的错误，那么bad()随即就给你安排一个。

这说明，这世上并不存在一个完美的算法，来准确的判定每个程序是否有某个非平凡的性质P。

而只要我们能构造的出一个反例，那就说明，还可以有成千上万的反例。

## 图灵机停机问题的证明：

https://blog.csdn.net/baimafujinji/article/details/50179715