---
title: 设计模式——状态模式
date: 2021-12-10
description: 设计模式状态模式的复习资料
categories:
- 设计模式
- 大三上
- java
tags:
- 状态模式
- 代码
- 编程
---

# 状态模式

## 模式用途

- 在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。
- 在UML中可以使用状态图来描述对象状态的变化。

## 模式定义

状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。

## 模式结构

状态模式包含如下角色：

- Context: 环境类
- State: 抽象状态类
- ConcreteState: 具体状态类

## UML类图

![uml类图](../../.vuepress/public/img/statePattern.jpg)

## 时序图

<img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_State.jpg">

## 代码分析

环境角色类

```java
public class Content {
  //持有一个State类型的对象实例
  private State state;
  
  public void setState(State state) {
    this.state = state;
  }
  /**
   * 用户需要的接口方法
   */
  public void request(String sampleParameter) {
    //转调state来处理
    state.handle(sampleParameter);
  }
}
```

抽象状态类

```java
public interface State {
  /**
   * 状态对应的处理
   */
  public void handle(String sampleParameter);
}
```

具体状体类

```java
public class ConcreteStateA implements State {
  
  @Override
  public void handle(String simpleParameter) {
    System.out.println("ConcreteStateA is handling: " + sampleParameter);
  }
}

public class ConcreteStateB implements State {
  
  @Override
  public void handle(String simpleParameter) {
    System.out.println("ConcreteStateB is handling: " + sampleParameter);
  }
}


```

主方法

```java
public class StatePatterm {
  public static void main(String []args) {
    State stateA = new ConcreteStateA();
    State stateB = new ConcreteStateB();
    Content content = new Content();
    content.setState(stateA);
    content.request("芜湖");
    content.setState(stateB);
    content.request("开冲");
  }
}
```

## 模式分析

- 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。
- 状态模式的关键在于抽象出一个抽象类用来标识状态，这个抽象类包含了所有状态之间的转换，并且实现了不同状态对应的处理方法，每一个具体状态类都需要从抽象状态类中继承。

在状态模式结构中需要理解环境类与抽象状态类的作用：

- 环境类就是拥有状态的对象
- 抽象状态类里是不同状态的处理方法，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。

## 优点

- 封装了转换规则。
- 枚举了可能的状态
- 增加新状态和改变环境对象的行为很容易，
- 切换状态后的处理工作交给抽象类，避免了大片的if-else
- 可复用，多个环境对象不需要重新编写状态

## 缺点

- 增加对象个数
- 容易导致程序结构和代码混乱
- 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。

## 使用环境

- 对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。
- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。（减少if-else）

## 模式应用

最近正在用的一个应用，Jira，用来管理 Scrum 的，实现每个冲刺状态的变化、 比如`未开始`、`进行中`和`已完成`。

为啥我还想到了Promise的Pending、Fulfilled和Rejected

## 模式扩展

### 共享模式

在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。（设为static）

### 简单状态模式与可切换状态模式

- 简单状态模式：在生成静态类实例的时候直接设置状态，且该状体不需要进行状态转换。因此它遵循了“开闭原则”，我们可以对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不会造成任何影响。
- 可切换状态模式：需要在环境类中设置`setState()`方法用来修改状态，为了不同状态都能够处理环境类，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换。在这种可以切换状态的状态模式中，增加新的状态类可能需要修改其他某些状态类甚至环境类的源代码，否则系统无法切换到新增状态。

## 总结：

- 状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。
- 状态模式包含三个角色：环境类是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。
- 状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。
- 状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。
- 状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。