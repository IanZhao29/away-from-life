(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{609:function(v,_,l){"use strict";l.r(_);var i=l(12),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"自顶向下计算机网络第五章-网络层-控制平面"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#自顶向下计算机网络第五章-网络层-控制平面"}},[v._v("#")]),v._v(" 自顶向下计算机网络第五章：网络层——控制平面")]),v._v(" "),l("p",[v._v("[toc]")]),v._v(" "),l("h2",{attrs:{id:"导论"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#导论"}},[v._v("#")]),v._v(" 导论")]),v._v(" "),l("p",[v._v("网络层需要实现的两个功能：")]),v._v(" "),l("ol",[l("li",[v._v("转发： 将分组从路由器的一 个"),l("code",[v._v("输入端口")]),v._v("移到合适的"),l("code",[v._v("输出端口")]),v._v("(数据平面)")]),v._v(" "),l("li",[v._v("路由：确定分组从源到目标的路径（控制平面）")])]),v._v(" "),l("h3",{attrs:{id:"_2种构建网络控制平面功能的方法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2种构建网络控制平面功能的方法"}},[v._v("#")]),v._v(" 2种构建网络控制平面功能的方法：")]),v._v(" "),l("ul",[l("li",[v._v("每个路由器控制功能实现（传统）：在每一个路由器中的单独路由器算法元件，在控制平面进行交互。")]),v._v(" "),l("li",[v._v("软件定义网络：一个不同的（通常是远程）控制器与本地控制代理（CAs）交互")])]),v._v(" "),l("h2",{attrs:{id:"路由选择算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#路由选择算法"}},[v._v("#")]),v._v(" 路由选择算法：")]),v._v(" "),l("h3",{attrs:{id:"路由的概念"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#路由的概念"}},[v._v("#")]),v._v(" 路由的概念：")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("路由: 按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径")]),v._v(" "),l("ul",[l("li",[v._v("较好路径：按照某种指标较小的路径")]),v._v(" "),l("li",[v._v("指标：啥都行，vip，vvvip之类的")]),v._v(" "),l("li",[v._v("采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什么指标网络使用者比较重视。")])])]),v._v(" "),l("li",[l("p",[v._v("以"),l("strong",[v._v("网络")]),v._v("为单位进行路由(路由信息通告+路由计算)")]),v._v(" "),l("ul",[l("li",[v._v("网络为单位进行路由，路由信息传输、计算和匹配的代价低")]),v._v(" "),l("li",[v._v("前提条件是:一个网络所有节点地址前缀相同，且物理上聚集")]),v._v(" "),l("li",[v._v("路由就是: 计算网络到其他网络如何走的问题")])])]),v._v(" "),l("li",[l("p",[v._v("网络到网络的路由= 路由器-路由器之间路由")]),v._v(" "),l("ul",[l("li",[v._v("网络对应的路由器到其他网络对应的路由器的路由")]),v._v(" "),l("li",[v._v("在一个网络中: 路由器-主机之间的通信，链路层解决")]),v._v(" "),l("li",[v._v("到了这个路由器就是到了这个网络")])])]),v._v(" "),l("li",[l("p",[v._v("路由选择算法(routing algorithm): 网络层软件的一部分,完成 路由功能")])])]),v._v(" "),l("h3",{attrs:{id:"汇集树-sink-tree"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#汇集树-sink-tree"}},[v._v("#")]),v._v(" 汇集树（sink tree）：")]),v._v(" "),l("ul",[l("li",[v._v("此节点到所有其它节点的最优路径形成的树")]),v._v(" "),l("li",[v._v("路由选择算法就是为所有路由器找到并使用"),l("code",[v._v("汇集树")])])]),v._v(" "),l("h3",{attrs:{id:"路由的原则"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#路由的原则"}},[v._v("#")]),v._v(" 路由的原则：")]),v._v(" "),l("ul",[l("li",[v._v("正确性（correctness）：算法必须是正确的和完整的")]),v._v(" "),l("li",[v._v("简单性（simplicity）：算法要简单、复杂度不能太高")]),v._v(" "),l("li",[v._v("健壮性（robustess）：能够不断更新迭代，也能够及时处理错误")]),v._v(" "),l("li",[v._v("稳定性（stability）：产生的路由不应该摇摆")]),v._v(" "),l("li",[v._v("公平性（fairness）：对每一个站点都公平")]),v._v(" "),l("li",[v._v("最优性（optimality）：某个指标最优，若最优代价太高，也可以是次优的。")])]),v._v(" "),l("h3",{attrs:{id:"算法分类"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#算法分类"}},[v._v("#")]),v._v(" 算法分类：")]),v._v(" "),l("ul",[l("li",[v._v("按区域：\n"),l("ul",[l("li",[v._v("全局：所有路由器都拥有完整拓扑（LS算法）")]),v._v(" "),l("li",[v._v("分布式：路由只知道到邻居路由器的代价，迭代地交换信息（DV算法）")])])]),v._v(" "),l("li",[v._v("按状态：\n"),l("ul",[l("li",[v._v("静态：不能适应网络拓扑和通信量的变化,路由表 是事先计算好的")]),v._v(" "),l("li",[v._v("动态： 能适应网络拓扑和通信量的变化")])])])]),v._v(" "),l("h3",{attrs:{id:"link-state-ls"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#link-state-ls"}},[v._v("#")]),v._v(" Link State（LS）")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("各点通过各种渠道获得整个网络拓扑, 网络中所有链路 代价等信息(这部分和算法没关系，属于协议和实现)")])]),v._v(" "),l("li",[l("p",[v._v("使用LS路由算法,计算本站点到其它站点的最优路径(汇 集树),得到路由表")])]),v._v(" "),l("li",[l("p",[v._v("按照路由表转发分组")])]),v._v(" "),l("li",[l("p",[v._v("发现相邻节点,获知对方网络地址")]),v._v(" "),l("ol",[l("li",[v._v("一个路由器上电之后,向所有线路发送HELLO分组")]),v._v(" "),l("li",[v._v("其它路由器收到HELLO分组,回送应答,在应答分组中,告 知自己的名字(全局唯一)")]),v._v(" "),l("li",[v._v("在LAN中,通过广播HELLO分组,获得其它路由器的信息, 可以认为引入一个人工节点")])])]),v._v(" "),l("li",[l("p",[v._v("测量到相邻节点的代价(延迟,开销)")]),v._v(" "),l("ol",[l("li",[v._v("通过Hi过去再Hi回来，计算延迟")])])]),v._v(" "),l("li",[l("p",[v._v("组装一个LS分组,描述它到相邻节点的代价情况")]),v._v(" "),l("ol",[l("li",[v._v("自己的名字（唯一标识）")]),v._v(" "),l("li",[v._v("序号，年龄（TTL）")]),v._v(" "),l("li",[v._v("列表: 给出它相邻节点,和它到相邻节点的延迟")])])]),v._v(" "),l("li",[l("p",[v._v("将分组通过扩散的方法发到所有其它路由器")]),v._v(" "),l("ol",[l("li",[v._v("顺序号: 用于控制无穷的扩散,每个路由器都记录( 源路由器,顺序号),发现重复的或老的就不扩散")]),v._v(" "),l("li",[v._v("利用年龄（TTL）解决顺序号出错等问题")]),v._v(" "),l("li",[v._v("扩散分组的数据结构：\n"),l("ol",[l("li",[v._v("Source :从哪个节点收到LS分组")]),v._v(" "),l("li",[v._v("Seq,Age:序号,年龄")]),v._v(" "),l("li",[v._v("Send flags:发送标记,必须向指定的哪些相邻站点转发LS分组")]),v._v(" "),l("li",[v._v("ACK flags:本站点必须向哪些相邻站点发送应答")]),v._v(" "),l("li",[v._v("DATA:来自source站点的LS分组")]),v._v(" "),l("li",[v._v("节点B的数据结构")])])])])]),v._v(" "),l("li",[l("p",[v._v("通过Dijkstra算法找出最短路径(这才是路由算法)")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);