(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{551:function(t,r,a){t.exports=a.p+"assets/img/interpretPattern.f431c010.png"},615:function(t,r,a){"use strict";a.r(r);var s=a(12),e=Object(s.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"设计模式-解释器模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计模式-解释器模式"}},[t._v("#")]),t._v(" 设计模式——解释器模式")]),t._v(" "),s("h2",{attrs:{id:"定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义：")]),t._v(" "),s("p",[t._v("解释器这个名词想必大家都不会陌生，比如编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。诸如此类的例子也有很多，比如编译器、正则表达式等等。")]),t._v(" "),s("p",[t._v("如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子，这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。")]),t._v(" "),s("p",[t._v("就比如正则表达式，它就是解释器模型的一种应用，解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式。")]),t._v(" "),s("p",[s("strong",[t._v("解释器模式（Interpreter）")]),t._v("，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。")]),t._v(" "),s("h2",{attrs:{id:"角色"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#角色"}},[t._v("#")]),t._v(" 角色：")]),t._v(" "),s("ul",[s("li",[t._v("环境角色Context：用来声明一些全局信息")]),t._v(" "),s("li",[t._v("抽象表达式AbstractExpression：声明一个抽象的解释操作")]),t._v(" "),s("li",[t._v("终结符表达式TerminalExpression：代表语法的终结符")]),t._v(" "),s("li",[t._v("非终结符表达式NonterminalExpression：代表语法的非终结符")])]),t._v(" "),s("h2",{attrs:{id:"uml"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uml"}},[t._v("#")]),t._v(" UML")]),t._v(" "),s("p",[s("img",{attrs:{src:a(551),alt:"interpretPattern"}})]),t._v(" "),s("h2",{attrs:{id:"优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点：")]),t._v(" "),s("ul",[s("li",[t._v("扩展性好：修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。")])]),t._v(" "),s("h2",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点：")]),t._v(" "),s("ul",[s("li",[t._v("解释器模式会引起类的膨胀：每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦。")]),t._v(" "),s("li",[t._v("解释器模式采用递归调用方法，将会导致调试非常复杂：每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。")]),t._v(" "),s("li",[t._v("效率低：使用大量递归和循环，时间空间都不占优，特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。")])])])}),[],!1,null,null,null);r.default=e.exports}}]);